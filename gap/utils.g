#############################################################################
##
#F  OD_SizeOfFieldOfDefinition( <vals>, <p> )
##
##  Assume that the condition holds for all Galois conjugates of entries in
##  <vals>.
##
OD_SizeOfFieldOfDefinition:= function( vals, p )
    local values, entry, q;

    # The first argument may be a list of cyclotomics.
    if   ForAll( vals, IsInt ) then
      return p;
    elif not ( IsList( vals ) and IsCyclotomicCollection( vals ) ) then
      Error( "<vals> must be a list of cyclotomics" );
    fi;

    values:= [];
    for entry in vals do
      if DenominatorCyc( entry ) mod p = 0 or
         Conductor( entry ) mod p = 0 then
        return fail;
      elif not IsRat( entry ) then
        Add( values, entry );
      fi;
    od;

    if ForAll( values, x -> IsCycInt( ( GaloisCyc( x, p ) - x ) / p ) ) then
      # All reductions lie in the prime field.
      return p;
    else
      # It is sufficient to look at powers of the map '*p'.
      q:= p;
      while true do
        q:= q * p;
        if ForAll( values,
                   x -> IsCycInt( ( GaloisCyc( x, q ) - x ) / p ) ) then
          return q;
        fi;
      od;
    fi;
end;


#############################################################################
##
#F  CharacterField( <chi>[, <p>] )
##
##  For an ordinary character <chi>, return the field generated by the values
##  of <chi>.
##  For a <p>-Brauer character <chi>, return the smallest finite field that
##  contains the <p>-modular reductions of the values of <chi>.
##
CharacterField:= function( chi, p... )
    if IsClassFunction( chi ) then
      p:= UnderlyingCharacteristic( UnderlyingCharacterTable( chi ) );
      chi:= ValuesOfClassFunction( chi );
    elif IsList( chi ) and Length( p ) = 1 then
      p:= p[1];
    else
      Error( "<chi> must be a class function, or <p> must be given" );
    fi;

    if p = 0 then
      return Field( Rationals, chi );
    else
      return GF( OD_SizeOfFieldOfDefinition( chi, p ) );
    fi;
end;
#T turn into a GAP attribute


#############################################################################
##
#F  StringOfCharacterField( <chi> )
##
StringOfCharacterField:= function( chi )
    local F, gens;

    F:= CharacterField( chi );
    if IsRationals( F ) then
      return "Q";
    fi;
    gens:= List( GeneratorsOfField( F ), CTblLib.StringOfAtlasIrrationality );

    return Concatenation( "Q(", JoinStringsWithSeparator( gens, ", " ), ")" );
end;

#############################################################################
##
#F  IsSquareInFiniteField( <F>, <val> )
##
##  Let <F> be a finite field of odd order $q$, or an odd prime power $q$,
##  and let <val> be either an element $x$ in the field with $q$ elements
##  or a cyclotomic that can be reduced to a nonzero element $x$ in this
##  finite field, via 'FrobeniusCharacterValue'.
##
##  'IsSquareInFiniteField' returns 'true' if $x$ is a square in the field
##  with $q$ elements, and 'false' otherwise.
##
IsSquareInFiniteField:= function( F, val )
    local q, p;

    if IsField( F ) then
      q:= Size( F );
      p:= Characteristic( F );
    elif IsPrimePowerInt( F ) then
      q:= F;
      p:= PrimeBase( q );
    else
      Error( "<F> must be a finite field or a prime power" );
    fi;

    if p = 2 then
      Error( "<p> must be odd" );
    elif Characteristic( val ) = 0 then
      val:= FrobeniusCharacterValueFixed( val, p );
    fi;

    if val = fail or IsZero( val ) then
      Error( "the value cannot be reduced" );
    fi;

    val:= (q-1) / Order( val );
    if not IsInt( val ) then
      Error( "the value dos not lie in the field in question" );
    fi;

    return IsEvenInt( val );
end;


#############################################################################
##
#F  SquareRootInNumberField( <F>, <val> )
##
##  Let <F> be a number field, and let <val> be an element in <F>.
##
##  'SquareRootInNumberField' returns an element $x$ with the property
##  $x^2$ = <val> if such an element exists, and 'fail' otherwise.
##
SquareRootInNumberField:= function( F, val )
    local facts;

    facts:= Factors( PolynomialRing( F ), Indeterminate(F)^2 - val );
    if Length( facts ) = 1 then
      return fail;
    fi;
    return Value( facts[1], 0 );
end;

